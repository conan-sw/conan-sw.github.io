[
  {
    "objectID": "disc03/Q2.html",
    "href": "disc03/Q2.html",
    "title": "Pandas + EDA exam prep (modeled after Fa22 Midterm Q1)",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nIt’s the annual Monopoly World Championship! The finalists: Shawn, Amanda, Neil, and Annie are playing Monopoly, a board game where players pay a price to buy properties, which can then generate income for them. Each property can be owned by only one player at a time. At the end of the game, the player with the most money wins.\nShawn wants to figure out which properties are most worth buying. He creates a DataFrame income with data on the current game state, shown on the left. He also finds a DataFrame properties with data on Monopoly properties, shown on the right.\nBoth tables have 28 rows. For brevity, only the first few rows of each DataFrame are shown.\n\n# First DataFrame: income\ndata_income = {\n    'Player': ['Shawn', 'Amanda', 'Neil', np.nan, 'Shawn', 'Annie', 'Amanda'],\n    'Property': ['Boardwalk', 'Park Place', 'Marvin Gardens', 'Kentucky Ave', 'Pennsylvania Ave', 'Oriental Ave', 'Baltic Ave'],\n    'Income Generated': ['$425', '$375', '$200', np.nan, '$150', '$50', '$60']\n}\n\nincome = pd.DataFrame(data_income)\nincome\n\n\n\n\n\n\n\n\nPlayer\nProperty\nIncome Generated\n\n\n\n\n0\nShawn\nBoardwalk\n$425\n\n\n1\nAmanda\nPark Place\n$375\n\n\n2\nNeil\nMarvin Gardens\n$200\n\n\n3\nNaN\nKentucky Ave\nNaN\n\n\n4\nShawn\nPennsylvania Ave\n$150\n\n\n5\nAnnie\nOriental Ave\n$50\n\n\n6\nAmanda\nBaltic Ave\n$60\n\n\n\n\n\n\n\nincome\n\nPlayer is the name of the player, as a str.\nProperty is a property currently owned by the player, as a str.\nIncome Generated is the amount of income a player has earned from that property so far, as a str.\n\n\n# Second DataFrame: properties\ndata_properties = {\n    'Property': ['Park Place', 'Oriental Ave', 'Vermont Ave', 'Pacific Ave', 'Boardwalk', 'Illinois Ave', 'Atlantic Ave'],\n    'Property Color': ['Dark Blue', 'Light Blue', 'Light Blue', 'Green', 'Dark Blue', 'Red', 'Yellow'],\n    'Purchase Price': [350.0, 100.0, 100.0, 300.0, 400.0, 240.0, 260.0]\n}\n\nproperties = pd.DataFrame(data_properties)\nproperties\n\n\n\n\n\n\n\n\nProperty\nProperty Color\nPurchase Price\n\n\n\n\n0\nPark Place\nDark Blue\n350.0\n\n\n1\nOriental Ave\nLight Blue\n100.0\n\n\n2\nVermont Ave\nLight Blue\n100.0\n\n\n3\nPacific Ave\nGreen\n300.0\n\n\n4\nBoardwalk\nDark Blue\n400.0\n\n\n5\nIllinois Ave\nRed\n240.0\n\n\n6\nAtlantic Ave\nYellow\n260.0\n\n\n\n\n\n\n\nproperties\n\nProperty is the name of the property, as a str. There are 28 unique properties.\nProperty Color is a color group that the property belongs to, as a str. There are 10 unique color groups, and each property belongs to a single group.\nPurchase Price is the price to buy the property, as a float.\n\nNote: For the properties that are not currently owned by any player, the Player and Income Generated columns in the income table have a NaN value.\n(a) What is the granularity of the income table?\n\n\nAnswer\n\n\nProperty\n\nEach unique property has its own row\nNotice how one player can have own multiple properties and can appear in multiple rows! This tells us that the granularity of this table is not Player.\n\n\n(b) Consider the Player and Purchase Price variables. What type of variable is each one? (quantitative, qualitative nominal, qualitative ordinal)\n\n\nAnswer\n\n\nPlayer: Qualitative nominal\nPurchase Price: Quantitative\n\n\n(c) Which of the following line(s) of code successfully returns a Series with the number of properties each player owns? Select all that apply.\n\n\nAnswer\n\n\nincome[\"Player\"].value_counts()\nincome.groupby(\"Player\").size()\n\n\n\nincome.groupby(\"Player\").agg(pd.value_counts)\n\n\n\n\n\n\n\n\nProperty\nIncome Generated\n\n\nPlayer\n\n\n\n\n\n\nAmanda\n[1, 1]\n[1, 1]\n\n\nAnnie\n1\n1\n\n\nNeil\n1\n1\n\n\nShawn\n[1, 1]\n[1, 1]\n\n\n\n\n\n\n\n\nincome[\"Player\"].value_counts()\n\nPlayer\nShawn     2\nAmanda    2\nNeil      1\nAnnie     1\nName: count, dtype: int64\n\n\n\nincome[\"Player\", \"Property\"].groupby(\"Player\").size()\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nFile /srv/conda/envs/notebook/lib/python3.11/site-packages/pandas/core/indexes/base.py:3652, in Index.get_loc(self, key)\n   3651 try:\n-&gt; 3652     return self._engine.get_loc(casted_key)\n   3653 except KeyError as err:\n\nFile /srv/conda/envs/notebook/lib/python3.11/site-packages/pandas/_libs/index.pyx:147, in pandas._libs.index.IndexEngine.get_loc()\n\nFile /srv/conda/envs/notebook/lib/python3.11/site-packages/pandas/_libs/index.pyx:176, in pandas._libs.index.IndexEngine.get_loc()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7080, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7088, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nKeyError: ('Player', 'Property')\n\nThe above exception was the direct cause of the following exception:\n\nKeyError                                  Traceback (most recent call last)\nCell In[16], line 1\n----&gt; 1 income[\"Player\", \"Property\"].groupby(\"Player\").size()\n\nFile /srv/conda/envs/notebook/lib/python3.11/site-packages/pandas/core/frame.py:3761, in DataFrame.__getitem__(self, key)\n   3759 if self.columns.nlevels &gt; 1:\n   3760     return self._getitem_multilevel(key)\n-&gt; 3761 indexer = self.columns.get_loc(key)\n   3762 if is_integer(indexer):\n   3763     indexer = [indexer]\n\nFile /srv/conda/envs/notebook/lib/python3.11/site-packages/pandas/core/indexes/base.py:3654, in Index.get_loc(self, key)\n   3652     return self._engine.get_loc(casted_key)\n   3653 except KeyError as err:\n-&gt; 3654     raise KeyError(key) from err\n   3655 except TypeError:\n   3656     # If we have a listlike key, _check_indexing_error will raise\n   3657     #  InvalidIndexError. Otherwise we fall through and re-raise\n   3658     #  the TypeError.\n   3659     self._check_indexing_error(key)\n\nKeyError: ('Player', 'Property')\n\n\n\n\nincome.groupby(\"Player\")[[\"Player\"]].count()\n\n\n\n\n\n\n\n\nPlayer\n\n\nPlayer\n\n\n\n\n\nAmanda\n2\n\n\nAnnie\n1\n\n\nNeil\n1\n\n\nShawn\n2\n\n\n\n\n\n\n\n(d) He now decides to calculate the amount of profit from each property. He wants to store this in a column called Profit in the income DataFrame. To do this, he first has to transform the Income Generated column to be of a float datatype.\nWrite one line of code to replace the old column with a new column, also called Income Generated, with the datatype modification described above. You may assume that each entry in Income Generated consists of a dollar sign ($) followed by a number, except for the NaN values.\n\n# (d) Answer\n\n(e) Assuming that the answer to (c) is correct, let’s add a Profit column to the income DataFrame. Fill in the following blanks to do this, and please add arguments to function class as you see appropriate.\nNote: Profit is calculated by subtracting the purchase price from generated income.\ncombined_df = income._____A_____(_______B_______)\nincome[\"Profit\"] = _______C_______\n\ncombined_df = income._____A_____(_____B_____)\nincome[\"Profit\"] = _____C_____\n\n(f) Shawn realizes he’s lost more money than he’s made. To solve this problem, he begins by writing some Pandas code to merge the Property Color column into the income DataFrame and drops all rows with NaN values. He calls this DataFrame merged_df. \nShawn decides he will now only buy properties from a color group that he deems “profitable.” He deems a color group “profitable” if at least 50% of the properties in the group that are currently owned by players have made a positive (non-zero) profit for those players.\nFill in the following lines of code to help him display a DataFrame with a subset of the rows in merged_df: the rows with properties that belong to profitable color groups. Your solution may use fewer lines of code than we provide.\n\n# def func(group):\n\n\n\n\n\n# merged_df.______________________________________________"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "disc02/disc02.html",
    "href": "disc02/disc02.html",
    "title": "Discussion 2: Pandas Practice",
    "section": "",
    "text": "This discussion is all about practicing using pandas, and testing your knowledge about its various functionalities to accomplish small tasks.\nWe will be using the elections dataset from lecture.\n# import packages\nimport pandas as pd\nimport numpy as np\nelections = pd.read_csv('elections.csv')\nelections.head(10)\n\n\n\n\n\n\n\n\nYear\nCandidate\nParty\nPopular vote\nResult\n%\n\n\n\n\n0\n1824\nAndrew Jackson\nDemocratic-Republican\n151271\nloss\n57.210122\n\n\n1\n1824\nJohn Quincy Adams\nDemocratic-Republican\n113142\nwin\n42.789878\n\n\n2\n1828\nAndrew Jackson\nDemocratic\n642806\nwin\n56.203927\n\n\n3\n1828\nJohn Quincy Adams\nNational Republican\n500897\nloss\n43.796073\n\n\n4\n1832\nAndrew Jackson\nDemocratic\n702735\nwin\n54.574789\n\n\n5\n1832\nHenry Clay\nNational Republican\n484205\nloss\n37.603628\n\n\n6\n1832\nWilliam Wirt\nAnti-Masonic\n100715\nloss\n7.821583\n\n\n7\n1836\nHugh Lawson White\nWhig\n146109\nloss\n10.005985\n\n\n8\n1836\nMartin Van Buren\nDemocratic\n763291\nwin\n52.272472\n\n\n9\n1836\nWilliam Henry Harrison\nWhig\n550816\nloss\n37.721543"
  },
  {
    "objectID": "disc02/disc02.html#problem-1",
    "href": "disc02/disc02.html#problem-1",
    "title": "Discussion 2: Pandas Practice",
    "section": "Problem 1",
    "text": "Problem 1\nWrite a line of code that returns the elections table sorted in descending order by \"Popular vote\". Store your result in a variable named sorted. Would calling sorted.iloc[[0], :] give the same result as sorted.loc[[0], :]?\n\n# Answer\nsorted = elections.sort_values(\"Popular vote\", ascending = False)\nsorted\n\n\n\n\n\n\n\n\nYear\nCandidate\nParty\nPopular vote\nResult\n%\n\n\n\n\n178\n2020\nJoseph Biden\nDemocratic\n81268924\nwin\n51.311515\n\n\n182\n2024\nDonald Trump\nRepublican\n77303568\nwin\n49.808629\n\n\n183\n2024\nKamala Harris\nDemocratic\n75019230\nloss\n48.336772\n\n\n179\n2020\nDonald Trump\nRepublican\n74216154\nloss\n46.858542\n\n\n162\n2008\nBarack Obama\nDemocratic\n69498516\nwin\n53.023510\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n110\n1956\nT. Coleman Andrews\nStates' Rights\n107929\nloss\n0.174883\n\n\n141\n1992\nBo Gritz\nPopulist\n106152\nloss\n0.101918\n\n\n99\n1948\nClaude A. Watson\nProhibition\n103708\nloss\n0.212747\n\n\n89\n1932\nWilliam Z. Foster\nCommunist\n103307\nloss\n0.261069\n\n\n6\n1832\nWilliam Wirt\nAnti-Masonic\n100715\nloss\n7.821583\n\n\n\n\n187 rows × 6 columns\n\n\n\n\n\nExplanation\n\n \n\nWe can sort a DataFrame by a column using the .sort_values() function! Remember to specify ascending = False, or else it will sort in increasing order.\n\n\n\n\nsorted.iloc[[0], :]\n\n\n\n\n\n\n\n\nYear\nCandidate\nParty\nPopular vote\nResult\n%\n\n\n\n\n178\n2020\nJoseph Biden\nDemocratic\n81268924\nwin\n51.311515\n\n\n\n\n\n\n\n\nsorted.loc[[0], :]\n\n\n\n\n\n\n\n\nYear\nCandidate\nParty\nPopular vote\nResult\n%\n\n\n\n\n0\n1824\nAndrew Jackson\nDemocratic-Republican\n151271\nloss\n57.210122\n\n\n\n\n\n\n\n\n\nExplanation\n\n \n\nThe difference is that .loc[] uses label-based indexing, while .iloc[] uses integer position-based indexing. Using .loc[] will simply grab the row with the label 0 regardless of where it is, while .iloc[] will grab the first row of the sorted DataFrame."
  },
  {
    "objectID": "disc02/disc02.html#problem-2",
    "href": "disc02/disc02.html#problem-2",
    "title": "Discussion 2: Pandas Practice",
    "section": "Problem 2",
    "text": "Problem 2\nUsing Boolean slicing, write one line of pandas code that returns a DataFrame that only contains election results from the 1900s.\n\n#Answer\nelections[(elections[\"Year\"] &gt;= 1900) & (elections[\"Year\"] &lt; 2000)]\n\n\n\n\n\n\n\n\nYear\nCandidate\nParty\nPopular vote\nResult\n%\n\n\n\n\n54\n1900\nJohn G. Woolley\nProhibition\n210864\nloss\n1.526821\n\n\n55\n1900\nWilliam Jennings Bryan\nDemocratic\n6370932\nloss\n46.130540\n\n\n56\n1900\nWilliam McKinley\nRepublican\n7228864\nwin\n52.342640\n\n\n57\n1904\nAlton B. Parker\nDemocratic\n5083880\nloss\n37.685116\n\n\n58\n1904\nEugene V. Debs\nSocialist\n402810\nloss\n2.985897\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n146\n1996\nHarry Browne\nLibertarian\n485759\nloss\n0.505198\n\n\n147\n1996\nHoward Phillips\nTaxpayers\n184656\nloss\n0.192045\n\n\n148\n1996\nJohn Hagelin\nNatural Law\n113670\nloss\n0.118219\n\n\n149\n1996\nRalph Nader\nGreen\n685297\nloss\n0.712721\n\n\n150\n1996\nRoss Perot\nReform\n8085294\nloss\n8.408844\n\n\n\n\n97 rows × 6 columns\n\n\n\n\n\nExplanation\n\n \n\nWe can “filter” DataFrames by using boolean slicing! 1. Construct a boolean Series that is True if a row contains election results from the 1900s, and False otherwise. * We can use the & (and) logical operator! 1900 or after and before 2000. 2. Use the boolean Series to slice the DataFrame * df[boolean_array]"
  },
  {
    "objectID": "disc02/disc02.html#problem-3",
    "href": "disc02/disc02.html#problem-3",
    "title": "Discussion 2: Pandas Practice",
    "section": "Problem 3",
    "text": "Problem 3\nWrite one line of pandas code that returns a Series, where the index is the \"Party\", and the values are how many times that party won an election. Only include parties that have won an election.\n\n#Answer\nelections[elections[\"Result\"] == \"win\"][\"Party\"].value_counts()\n\nParty\nRepublican               24\nDemocratic               23\nWhig                      2\nDemocratic-Republican     1\nNational Union            1\nName: count, dtype: int64\n\n\n\n#Answer\nelections[elections[\"Result\"] == \"win\"].groupby(\"Party\").size()\n\nParty\nDemocratic               23\nDemocratic-Republican     1\nNational Union            1\nRepublican               24\nWhig                      2\ndtype: int64\n\n\n\n\nExplanation\n\n \n\nTwo parts to this! 1. Filter DataFrame to only include winners. * Use boolean slicing again! Construct a boolean Series that has True if the row contains a winner, and False otherwise * elections[elections[\"Result\"] == \"win\"] 2. Within filtered DataFrame (let’s call this winners), count the number of times each party won an election. Two ways to do this. * Extract the Party column from winners, and call value_counts(). * winners[\"Party\"].value_counts() * Group by the Party column, and aggregate by the number of rows in each sub-DataFrame. * winners.groupby(\"Party\").size() * The two methods above return the same thing, except .value_counts() sorts by the values in decreasing order, while .groupby() sort by the index in increasing order!"
  },
  {
    "objectID": "disc02/disc02.html#problem-4",
    "href": "disc02/disc02.html#problem-4",
    "title": "Discussion 2: Pandas Practice",
    "section": "Problem 4",
    "text": "Problem 4\nWrite a line of pandas code that returns a Series whose index is the years and whose values are the number of candidates that participated in those years’ elections.\n\n# Answer\nelections[\"Year\"].value_counts().head() #.head() to limit output\n\nYear\n1996    7\n1948    6\n1976    6\n2004    6\n2008    6\nName: count, dtype: int64\n\n\n\n# Answer\nelections.groupby(\"Year\").size().head() #.head() to limit output\n\nYear\n1824    2\n1828    2\n1832    3\n1836    3\n1840    2\ndtype: int64\n\n\n\n\nExplanation\n\n \n\nVery similar to Problem 3! Might even be easier, actually. Each row corresponds to one candidate per election cycle, so we simply need to count the number of times each Year appears in the elections DataFrame. Just like in Problem 3, two ways to do this.\n\nExtract the Year column as a Series, call .value_counts() on it.\n\nelections[\"Year\"].value_counts()\n\n\nGroup by the Year column, creating a sub-DataFrame for each unique Year. Aggregate by .size(), counting the number of rows in each sub-DataFrame.\n\nelections.groupby(\"Year\").size()"
  },
  {
    "objectID": "disc02/disc02.html#problem-5",
    "href": "disc02/disc02.html#problem-5",
    "title": "Discussion 2: Pandas Practice",
    "section": "Problem 5",
    "text": "Problem 5\nWrite a line of pandas code that creates a filtered DataFrame named filtered_parties from the elections dataset and keeps only the parties that have at least one election % more than 50%.\n\n# Answer\nfiltered_parties = elections.groupby(\"Party\").filter(lambda df: df[\"%\"].max() &gt; 50)\nfiltered_parties\n\n\n\n\n\n\n\n\nYear\nCandidate\nParty\nPopular vote\nResult\n%\n\n\n\n\n0\n1824\nAndrew Jackson\nDemocratic-Republican\n151271\nloss\n57.210122\n\n\n1\n1824\nJohn Quincy Adams\nDemocratic-Republican\n113142\nwin\n42.789878\n\n\n2\n1828\nAndrew Jackson\nDemocratic\n642806\nwin\n56.203927\n\n\n4\n1832\nAndrew Jackson\nDemocratic\n702735\nwin\n54.574789\n\n\n7\n1836\nHugh Lawson White\nWhig\n146109\nloss\n10.005985\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n176\n2016\nHillary Clinton\nDemocratic\n65853514\nloss\n48.521539\n\n\n178\n2020\nJoseph Biden\nDemocratic\n81268924\nwin\n51.311515\n\n\n179\n2020\nDonald Trump\nRepublican\n74216154\nloss\n46.858542\n\n\n182\n2024\nDonald Trump\nRepublican\n77303568\nwin\n49.808629\n\n\n183\n2024\nKamala Harris\nDemocratic\n75019230\nloss\n48.336772\n\n\n\n\n99 rows × 6 columns\n\n\n\n\n\nExplanation\n\n \n\nThis filtering is different from boolean slicing! Boolean slicing considers rows individually, while .filter() considers groups of rows. Rows of a sub-DataFrame either all make it, or none make it.\n\nGroup by the Party column, creating one sub-DataFrame for each party.\n\nelections.groupby(\"Party\")\n\nFilter using .filter()\n\nPass in a function into .filter() that takes in a DataFrame and returns True or False. Can be a lambda function!\n.filter(lambda df: df[\"%\"].max() &gt; 50)\n\nIf the lambda function returns True, it means you keep the entire sub-DataFrame. False means you exclude it entirely!"
  },
  {
    "objectID": "disc02/disc02.html#problem-6",
    "href": "disc02/disc02.html#problem-6",
    "title": "Discussion 2: Pandas Practice",
    "section": "Problem 6",
    "text": "Problem 6\nWrite a line of pandas code that uses the filtered_parties DataFrame to return a new DataFrame with row indices that correspond to the year and columns that correspond to each party. Each entry should be the total percentage of votes for all the candidates that ran during that particular year for the specified party. Missing values from the dataset (the cases where a party did not have a candidate in a particular year) should be entered as 0. Below is an example.\n\n\nelections_pivot = filtered_parties.pivot_table(\n    index = \"Year\",\n    columns = \"Party\",\n    values = \"%\",\n    aggfunc = np.sum,\n    fill_value = 0)\nelections_pivot\n\nC:\\Users\\conan\\AppData\\Local\\Temp\\ipykernel_16672\\3251603173.py:1: FutureWarning: The provided callable &lt;function sum at 0x000001D1EE547B00&gt; is currently using DataFrameGroupBy.sum. In a future version of pandas, the provided callable will be used directly. To keep current behavior pass the string \"sum\" instead.\n  elections_pivot = filtered_parties.pivot_table(\n\n\n\n\n\n\n\n\nParty\nDemocratic\nDemocratic-Republican\nNational Union\nRepublican\nWhig\n\n\nYear\n\n\n\n\n\n\n\n\n\n1824\n0.000000\n100.0\n0.000000\n0.000000\n0.000000\n\n\n1828\n56.203927\n0.0\n0.000000\n0.000000\n0.000000\n\n\n1832\n54.574789\n0.0\n0.000000\n0.000000\n0.000000\n\n\n1836\n52.272472\n0.0\n0.000000\n0.000000\n47.727528\n\n\n1840\n46.948787\n0.0\n0.000000\n0.000000\n53.051213\n\n\n1844\n50.749477\n0.0\n0.000000\n0.000000\n49.250523\n\n\n1848\n42.552229\n0.0\n0.000000\n0.000000\n47.309296\n\n\n1852\n51.013168\n0.0\n0.000000\n0.000000\n44.056548\n\n\n1856\n45.306080\n0.0\n0.000000\n33.139919\n0.000000\n\n\n1860\n0.000000\n0.0\n0.000000\n39.699408\n0.000000\n\n\n1864\n45.048488\n0.0\n54.951512\n0.000000\n0.000000\n\n\n1868\n47.334695\n0.0\n0.000000\n52.665305\n0.000000\n\n\n1872\n0.000000\n0.0\n0.000000\n55.928594\n0.000000\n\n\n1876\n51.528376\n0.0\n0.000000\n48.471624\n0.000000\n\n\n1880\n48.278422\n0.0\n0.000000\n48.369234\n0.000000\n\n\n1884\n48.884933\n0.0\n0.000000\n48.312208\n0.000000\n\n\n1888\n48.656799\n0.0\n0.000000\n47.858041\n0.000000\n\n\n1892\n46.121393\n0.0\n0.000000\n42.984101\n0.000000\n\n\n1896\n46.871053\n0.0\n0.000000\n51.213817\n0.000000\n\n\n1900\n46.130540\n0.0\n0.000000\n52.342640\n0.000000\n\n\n1904\n37.685116\n0.0\n0.000000\n56.562787\n0.000000\n\n\n1908\n43.414640\n0.0\n0.000000\n52.013300\n0.000000\n\n\n1912\n41.933422\n0.0\n0.000000\n23.218466\n0.000000\n\n\n1916\n49.367987\n0.0\n0.000000\n46.240779\n0.000000\n\n\n1920\n34.293063\n0.0\n0.000000\n60.574501\n0.000000\n\n\n1924\n28.976291\n0.0\n0.000000\n54.329113\n0.000000\n\n\n1928\n40.902853\n0.0\n0.000000\n58.368524\n0.000000\n\n\n1932\n57.672125\n0.0\n0.000000\n39.830594\n0.000000\n\n\n1936\n60.978107\n0.0\n0.000000\n36.648285\n0.000000\n\n\n1940\n54.871202\n0.0\n0.000000\n44.894561\n0.000000\n\n\n1944\n53.773801\n0.0\n0.000000\n46.226199\n0.000000\n\n\n1948\n49.601536\n0.0\n0.000000\n45.112958\n0.000000\n\n\n1952\n44.446312\n0.0\n0.000000\n55.325173\n0.000000\n\n\n1956\n42.174464\n0.0\n0.000000\n57.650654\n0.000000\n\n\n1960\n50.082561\n0.0\n0.000000\n49.917439\n0.000000\n\n\n1964\n61.344703\n0.0\n0.000000\n38.655297\n0.000000\n\n\n1968\n42.863537\n0.0\n0.000000\n43.565246\n0.000000\n\n\n1972\n37.670670\n0.0\n0.000000\n60.907806\n0.000000\n\n\n1976\n50.271900\n0.0\n0.000000\n48.199499\n0.000000\n\n\n1980\n41.132848\n0.0\n0.000000\n50.897944\n0.000000\n\n\n1984\n40.729429\n0.0\n0.000000\n59.023326\n0.000000\n\n\n1988\n45.770691\n0.0\n0.000000\n53.518845\n0.000000\n\n\n1992\n43.118485\n0.0\n0.000000\n37.544784\n0.000000\n\n\n1996\n49.296938\n0.0\n0.000000\n40.766036\n0.000000\n\n\n2000\n48.491813\n0.0\n0.000000\n47.974666\n0.000000\n\n\n2004\n48.306775\n0.0\n0.000000\n50.771824\n0.000000\n\n\n2008\n53.023510\n0.0\n0.000000\n45.737243\n0.000000\n\n\n2012\n51.258484\n0.0\n0.000000\n47.384076\n0.000000\n\n\n2016\n48.521539\n0.0\n0.000000\n46.407862\n0.000000\n\n\n2020\n51.311515\n0.0\n0.000000\n46.858542\n0.000000\n\n\n2024\n48.336772\n0.0\n0.000000\n49.808629\n0.000000\n\n\n\n\n\n\n\n\nThe Kernel crashed while executing code in the current cell or a previous cell. \n\nPlease review the code in the cell(s) to identify a possible cause of the failure. \n\nClick &lt;a href='https://aka.ms/vscodeJupyterKernelCrash'&gt;here&lt;/a&gt; for more info. \n\nView Jupyter &lt;a href='command:jupyter.viewOutput'&gt;log&lt;/a&gt; for further details.\n\n\n\n\n\nExplanation\n\n \n\nFirst thing to notice is that the columns are values of the Party column! This tells us that what we see is a pivot table.\n\nUse the .pivot_table() function on filtered_parties\n\nindex = \"Year\" and columns = \"Party\", saying that the unique values of Year should make up the row indices, and the unique values of Party should make up the columns.\nvalues = \"%\" indicates that we populate the cells with the % values for each combination of Year, Party\naggfunc = np.sum describes how to aggregate the values in a cell\nfill_value = 0 says to impute 0 in case there is no % value for a specific Year, Party combination"
  },
  {
    "objectID": "disc03/disc03.html",
    "href": "disc03/disc03.html",
    "title": "Pandas + EDA exam prep (modeled after Fa22 Midterm Q1)",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\n\nIt’s the annual Monopoly World Championship! The finalists: Shawn, Amanda, Neil, and Annie are playing Monopoly, a board game where players pay a price to buy properties, which can then generate income for them. Each property can be owned by only one player at a time. At the end of the game, the player with the most money wins.\nShawn wants to figure out which properties are most worth buying. He creates a DataFrame income with data on the current game state, shown on the left. He also finds a DataFrame properties with data on Monopoly properties, shown on the right.\nBoth tables have 28 rows. For brevity, only the first few rows of each DataFrame are shown.\n\n# First DataFrame: income\ndata_income = {\n    'Player': ['Shawn', 'Amanda', 'Neil', np.nan, 'Shawn', 'Annie', 'Amanda'],\n    'Property': ['Boardwalk', 'Park Place', 'Marvin Gardens', 'Kentucky Ave', 'Pennsylvania Ave', 'Oriental Ave', 'Baltic Ave'],\n    'Income Generated': ['$425', '$375', '$200', np.nan, '$150', '$50', '$60']\n}\n\nincome = pd.DataFrame(data_income)\nincome\n\n\n\n\n\n\n\n\nPlayer\nProperty\nIncome Generated\n\n\n\n\n0\nShawn\nBoardwalk\n$425\n\n\n1\nAmanda\nPark Place\n$375\n\n\n2\nNeil\nMarvin Gardens\n$200\n\n\n3\nNaN\nKentucky Ave\nNaN\n\n\n4\nShawn\nPennsylvania Ave\n$150\n\n\n5\nAnnie\nOriental Ave\n$50\n\n\n6\nAmanda\nBaltic Ave\n$60\n\n\n\n\n\n\n\nincome\n\nPlayer is the name of the player, as a str.\nProperty is a property currently owned by the player, as a str.\nIncome Generated is the amount of income a player has earned from that property so far, as a str.\n\n\n# Second DataFrame: properties\ndata_properties = {\n    'Property': ['Park Place', 'Oriental Ave', 'Vermont Ave', 'Pacific Ave', 'Boardwalk', 'Illinois Ave', 'Atlantic Ave'],\n    'Property Color': ['Dark Blue', 'Light Blue', 'Light Blue', 'Green', 'Dark Blue', 'Red', 'Yellow'],\n    'Purchase Price': [350.0, 100.0, 100.0, 300.0, 400.0, 240.0, 260.0]\n}\n\nproperties = pd.DataFrame(data_properties)\nproperties\n\n\n\n\n\n\n\n\nProperty\nProperty Color\nPurchase Price\n\n\n\n\n0\nPark Place\nDark Blue\n350.0\n\n\n1\nOriental Ave\nLight Blue\n100.0\n\n\n2\nVermont Ave\nLight Blue\n100.0\n\n\n3\nPacific Ave\nGreen\n300.0\n\n\n4\nBoardwalk\nDark Blue\n400.0\n\n\n5\nIllinois Ave\nRed\n240.0\n\n\n6\nAtlantic Ave\nYellow\n260.0\n\n\n\n\n\n\n\nproperties\n\nProperty is the name of the property, as a str. There are 28 unique properties.\nProperty Color is a color group that the property belongs to, as a str. There are 10 unique color groups, and each property belongs to a single group.\nPurchase Price is the price to buy the property, as a float.\n\nNote: For the properties that are not currently owned by any player, the Player and Income Generated columns in the income table have a NaN value.\n(a) What is the granularity of the income table?\n\n\nAnswer\n\n\nProperty\n\nEach unique property has its own row\nNotice how one player can have own multiple properties and can appear in multiple rows! This tells us that the granularity of this table is not Player.\n\n\n(b) Consider the Player and Purchase Price variables. What type of variable is each one? (quantitative, qualitative nominal, qualitative ordinal)\n\n\nAnswer\n\n\nPlayer: Qualitative nominal\nPurchase Price: Quantitative\n\n\n(c) Which of the following line(s) of code successfully returns a Series with the number of properties each player owns? Select all that apply.\n\n\nAnswer\n\n\nincome[\"Player\"].value_counts()\nincome.groupby(\"Player\").size()\n\n\n\nincome.groupby(\"Player\").agg(pd.value_counts)\n\n\n\n\n\n\n\n\nProperty\nIncome Generated\n\n\nPlayer\n\n\n\n\n\n\nAmanda\n[1, 1]\n[1, 1]\n\n\nAnnie\n1\n1\n\n\nNeil\n1\n1\n\n\nShawn\n[1, 1]\n[1, 1]\n\n\n\n\n\n\n\n\nincome[\"Player\"].value_counts()\n\nPlayer\nShawn     2\nAmanda    2\nNeil      1\nAnnie     1\nName: count, dtype: int64\n\n\n\nincome[\"Player\", \"Property\"].groupby(\"Player\").size()\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nFile /srv/conda/envs/notebook/lib/python3.11/site-packages/pandas/core/indexes/base.py:3652, in Index.get_loc(self, key)\n   3651 try:\n-&gt; 3652     return self._engine.get_loc(casted_key)\n   3653 except KeyError as err:\n\nFile /srv/conda/envs/notebook/lib/python3.11/site-packages/pandas/_libs/index.pyx:147, in pandas._libs.index.IndexEngine.get_loc()\n\nFile /srv/conda/envs/notebook/lib/python3.11/site-packages/pandas/_libs/index.pyx:176, in pandas._libs.index.IndexEngine.get_loc()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7080, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7088, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nKeyError: ('Player', 'Property')\n\nThe above exception was the direct cause of the following exception:\n\nKeyError                                  Traceback (most recent call last)\nCell In[16], line 1\n----&gt; 1 income[\"Player\", \"Property\"].groupby(\"Player\").size()\n\nFile /srv/conda/envs/notebook/lib/python3.11/site-packages/pandas/core/frame.py:3761, in DataFrame.__getitem__(self, key)\n   3759 if self.columns.nlevels &gt; 1:\n   3760     return self._getitem_multilevel(key)\n-&gt; 3761 indexer = self.columns.get_loc(key)\n   3762 if is_integer(indexer):\n   3763     indexer = [indexer]\n\nFile /srv/conda/envs/notebook/lib/python3.11/site-packages/pandas/core/indexes/base.py:3654, in Index.get_loc(self, key)\n   3652     return self._engine.get_loc(casted_key)\n   3653 except KeyError as err:\n-&gt; 3654     raise KeyError(key) from err\n   3655 except TypeError:\n   3656     # If we have a listlike key, _check_indexing_error will raise\n   3657     #  InvalidIndexError. Otherwise we fall through and re-raise\n   3658     #  the TypeError.\n   3659     self._check_indexing_error(key)\n\nKeyError: ('Player', 'Property')\n\n\n\n\nincome.groupby(\"Player\")[[\"Player\"]].count()\n\n\n\n\n\n\n\n\nPlayer\n\n\nPlayer\n\n\n\n\n\nAmanda\n2\n\n\nAnnie\n1\n\n\nNeil\n1\n\n\nShawn\n2\n\n\n\n\n\n\n\n(d) He now decides to calculate the amount of profit from each property. He wants to store this in a column called Profit in the income DataFrame. To do this, he first has to transform the Income Generated column to be of a float datatype.\nWrite one line of code to replace the old column with a new column, also called Income Generated, with the datatype modification described above. You may assume that each entry in Income Generated consists of a dollar sign ($) followed by a number, except for the NaN values.\n\n# (d) Answer\n\n(e) Assuming that the answer to (c) is correct, let’s add a Profit column to the income DataFrame. Fill in the following blanks to do this, and please add arguments to function class as you see appropriate.\nNote: Profit is calculated by subtracting the purchase price from generated income.\ncombined_df = income._____A_____(_______B_______)\nincome[\"Profit\"] = _______C_______\n\ncombined_df = income._____A_____(_____B_____)\nincome[\"Profit\"] = _____C_____\n\n(f) Shawn realizes he’s lost more money than he’s made. To solve this problem, he begins by writing some Pandas code to merge the Property Color column into the income DataFrame and drops all rows with NaN values. He calls this DataFrame merged_df. \nShawn decides he will now only buy properties from a color group that he deems “profitable.” He deems a color group “profitable” if at least 50% of the properties in the group that are currently owned by players have made a positive (non-zero) profit for those players.\nFill in the following lines of code to help him display a DataFrame with a subset of the rows in merged_df: the rows with properties that belong to profitable color groups. Your solution may use fewer lines of code than we provide.\n\n# def func(group):\n\n\n\n\n\n# merged_df.______________________________________________"
  },
  {
    "objectID": "disc01/disc01.html",
    "href": "disc01/disc01.html",
    "title": "Linear Algebra Fundamentals",
    "section": "",
    "text": "Linear algebra is what powers linear regression, logistic regression, and PCA (concepts that we will be studying in this course). This question aims to build an understanding of how matrix-vector operations work.   Consider yourself starstruck: it’s 2016, and you just spotted the first family of music, Beyonc ́e, husband Jay-Z, and their four year-old daughter Blue, shopping for fruit bowls at Berkeley Bowl. Each bowl contains some fruit and the price of a fruit bowl is simply the total price of all of its individual fruit.   Berkeley Bowl has apples for $2, bananas for $1, and cantaloupes for $4 (expensive!). The price of each of these can be written in a vector:\n\n\\[\\begin{align*}\n    \\vec{v} =\n        \\begin{bmatrix}\n        2\\\\\n        1\\\\\n        4\n        \\end{bmatrix}\n\\end{align*}\\]\nBerkeley Bowl sells the following fruit bowls: 1. 2 of each fruit 2. 5 apples and 8 bananas 3. 2 bananas and 3 cantaloupes 4. 10 cantaloupes"
  }
]