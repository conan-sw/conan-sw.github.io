<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Cross-Validation and Regularization</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="disc08_files/libs/clipboard/clipboard.min.js"></script>
<script src="disc08_files/libs/quarto-html/quarto.js"></script>
<script src="disc08_files/libs/quarto-html/popper.min.js"></script>
<script src="disc08_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="disc08_files/libs/quarto-html/anchor.min.js"></script>
<link href="disc08_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="disc08_files/libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="disc08_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="disc08_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="disc08_files/libs/bootstrap/bootstrap-aaac6a0f32702562ddb454902c357f36.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-full">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Cross-Validation and Regularization</h2>
   
  <ul>
  <li><a href="#link-to-slides" id="toc-link-to-slides" class="nav-link active" data-scroll-target="#link-to-slides">Link to Slides</a></li>
  <li><a href="#cross-validation" id="toc-cross-validation" class="nav-link" data-scroll-target="#cross-validation">Cross Validation</a>
  <ul class="collapse">
  <li><a href="#a" id="toc-a" class="nav-link" data-scroll-target="#a">(a)</a></li>
  <li><a href="#b" id="toc-b" class="nav-link" data-scroll-target="#b">(b)</a></li>
  </ul></li>
  <li><a href="#ridge-and-lasso-regression" id="toc-ridge-and-lasso-regression" class="nav-link" data-scroll-target="#ridge-and-lasso-regression">Ridge and LASSO Regression</a>
  <ul class="collapse">
  <li><a href="#a-1" id="toc-a-1" class="nav-link" data-scroll-target="#a-1">(a)</a></li>
  <li><a href="#b-1" id="toc-b-1" class="nav-link" data-scroll-target="#b-1">(b)</a></li>
  <li><a href="#c" id="toc-c" class="nav-link" data-scroll-target="#c">(c)</a></li>
  <li><a href="#d" id="toc-d" class="nav-link" data-scroll-target="#d">(d)</a></li>
  <li><a href="#e" id="toc-e" class="nav-link" data-scroll-target="#e">(e)</a></li>
  </ul></li>
  <li><a href="#guessing-at-random" id="toc-guessing-at-random" class="nav-link" data-scroll-target="#guessing-at-random">Guessing at Random</a>
  <ul class="collapse">
  <li><a href="#a-2" id="toc-a-2" class="nav-link" data-scroll-target="#a-2">(a)</a></li>
  <li><a href="#b-2" id="toc-b-2" class="nav-link" data-scroll-target="#b-2">(b)</a></li>
  <li><a href="#c-1" id="toc-c-1" class="nav-link" data-scroll-target="#c-1">(c)</a></li>
  <li><a href="#d-1" id="toc-d-1" class="nav-link" data-scroll-target="#d-1">(d)</a></li>
  <li><a href="#e-1" id="toc-e-1" class="nav-link" data-scroll-target="#e-1">(e)</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Cross-Validation and Regularization</h1>
</div>



<div class="quarto-title-meta column-page-left">

    
  
    
  </div>
  


</header>


<section id="link-to-slides" class="level3">
<h3 class="anchored" data-anchor-id="link-to-slides"><a href="https://docs.google.com/presentation/d/1F0IMB7RTXk-XbvDGfUlS13cwRPKp7pRtdv0HfZc2Irs/edit?usp=sharing">Link to Slides</a></h3>
</section>
<section id="cross-validation" class="level2">
<h2 class="anchored" data-anchor-id="cross-validation">Cross Validation</h2>
<section id="a" class="level3">
<h3 class="anchored" data-anchor-id="a">(a)</h3>
<p>After running <span class="math inline">\(5\)</span>-fold cross-validation, we get the following mean squared errors for each fold and value of <span class="math inline">\(\lambda\)</span> when using Ridge regularization:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Fold Num.</th>
<th style="text-align: center;"><span class="math inline">\(\lambda = 0.1\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\lambda = 0.2\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\lambda = 0.3\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\lambda = 0.4\)</span></th>
<th style="text-align: center;">Row Avg</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1</td>
<td style="text-align: center;">80.2</td>
<td style="text-align: center;">70.2</td>
<td style="text-align: center;">91.2</td>
<td style="text-align: center;">91.8</td>
<td style="text-align: center;">83.4</td>
</tr>
<tr class="even">
<td style="text-align: left;">2</td>
<td style="text-align: center;">76.8</td>
<td style="text-align: center;">66.8</td>
<td style="text-align: center;">88.8</td>
<td style="text-align: center;">98.8</td>
<td style="text-align: center;">82.8</td>
</tr>
<tr class="odd">
<td style="text-align: left;">3</td>
<td style="text-align: center;">81.5</td>
<td style="text-align: center;">71.5</td>
<td style="text-align: center;">86.5</td>
<td style="text-align: center;">88.5</td>
<td style="text-align: center;">82.0</td>
</tr>
<tr class="even">
<td style="text-align: left;">4</td>
<td style="text-align: center;">79.4</td>
<td style="text-align: center;">68.4</td>
<td style="text-align: center;">92.3</td>
<td style="text-align: center;">92.4</td>
<td style="text-align: center;">83.1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">5</td>
<td style="text-align: center;">77.3</td>
<td style="text-align: center;">67.3</td>
<td style="text-align: center;">93.4</td>
<td style="text-align: center;">94.3</td>
<td style="text-align: center;">83.0</td>
</tr>
<tr class="even">
<td style="text-align: left;">Col Avg</td>
<td style="text-align: center;">79.0</td>
<td style="text-align: center;">68.8</td>
<td style="text-align: center;">90.4</td>
<td style="text-align: center;">93.2</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>Suppose we wish to use the results of this 5-fold cross-validation to choose our hyperparameter <span class="math inline">\(\lambda\)</span>, among the following four choices in the table. Using the information in the table, which <span class="math inline">\(\lambda\)</span> would you choose? Why?</p>
<details>
<summary>
<b>Answer</b>
</summary>
<p>We should use <span class="math inline">\(\lambda = 0.2\)</span> because this value has the least average MSE across all folds.</p>
</details>
</section>
<section id="b" class="level3">
<h3 class="anchored" data-anchor-id="b">(b)</h3>
<p>You build a model with two hyperparameters, the coefficient for the regularization term (<span class="math inline">\(\lambda\)</span>) and our learning rate (<span class="math inline">\(\alpha\)</span>). You have 4 good candidate values for <span class="math inline">\(\lambda\)</span> and 3 possible values for <span class="math inline">\(\alpha\)</span>, and you are wondering which <span class="math inline">\(\lambda,
\alpha\)</span> pair will be the best choice. If you were to perform 5-fold cross-validation, how many validation errors would you need to calculate?</p>
<details>
<summary>
<b>Answer</b>
</summary>
<p>There are <span class="math inline">\(4 \times 3 = 12\)</span> pairs of <span class="math inline">\(\lambda, \alpha\)</span>, and each pair will have <span class="math inline">\(5\)</span> validation errors, one for each fold. So, there would be 60 validation errors in total.</p>
</details>
</section>
</section>
<section id="ridge-and-lasso-regression" class="level2">
<h2 class="anchored" data-anchor-id="ridge-and-lasso-regression">Ridge and LASSO Regression</h2>
<p>The goal of linear regression is to find the <span class="math inline">\(\theta\)</span> value that minimizes the average squared loss. In other words, we want to find <span class="math inline">\(\hat{\theta}\)</span> that satisfies the equation below:</p>
<p><span class="math display">\[\hat{\theta}
= \underset{\theta}{\operatorname{argmin}} L(\theta)
= \underset{\theta}{\operatorname{argmin}} \dfrac{1}{n}||\mathbb{Y} - \mathbb{X}{\theta}||_2^2\]</span></p>
<p>Here, <span class="math inline">\(\Bbb{X}\)</span> is a <span class="math inline">\(n \times (p + 1)\)</span> matrix, <span class="math inline">\(\theta\)</span> is a <span class="math inline">\((p + 1) \times 1\)</span> vector and <span class="math inline">\(\mathbb{Y}\)</span> is a <span class="math inline">\(n \times 1\)</span> vector. Recall that the extra <span class="math inline">\(1\)</span> in <span class="math inline">\((p+1)\)</span> comes from the intercept term. As we saw in lecture, the optimal <span class="math inline">\(\hat{\theta}\)</span> is given by the closed-form expression <span class="math inline">\(\hat{\theta} = (\Bbb{X}^T\Bbb{X})^{-1}\Bbb{X}^T \mathbb{Y}\)</span>.</p>
<p>To prevent overfitting, we saw that we can instead minimize the sum of the average squared loss plus a regularization term <span class="math inline">\(\lambda g(\theta)\)</span>. The optimization problem for such a loss function then becomes:</p>
<p><span class="math display">\[\begin{align*}
    \hat{\theta} = \underset{\theta}{\operatorname{argmin}} L(\theta) = \underset{\theta}{\operatorname{argmin}} \left[\frac{1}{n} \|\mathbb{Y} - \mathbb{X}\theta\|_{2}^{2} + \lambda g(\theta) \right]
\end{align*}\]</span></p>
<ul>
<li>If we use the function <span class="math inline">\(g(\theta) = \sum_{j=1}^p\theta_j^2 = ||{\theta}||_2^2\)</span>, we have “Ridge regression”. Recall that <span class="math inline">\(g\)</span> is the <span class="math inline">\(\ell_2\)</span> norm of <span class="math inline">\(\theta\)</span>, so this is also referred to as “<span class="math inline">\(\ell_2 / L_2\)</span> regularization”.</li>
<li>If we use the function <span class="math inline">\(g(\theta) = \sum_{j=1}^p |\theta_j| = ||{\theta}||_1\)</span>, we have “LASSO regression”. Recall that <span class="math inline">\(g\)</span> is the <span class="math inline">\(\ell_1\)</span> norm of <span class="math inline">\(\theta\)</span>, so this is also referred to as “<span class="math inline">\(\ell_1 / L_1\)</span> regularization”.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/ridge_lasso.gif" class="img-fluid figure-img"></p>
<figcaption>ridge_lasso</figcaption>
</figure>
</div>
<p><strong>In this question, we intentionally choose to regularize also on the intercept term</strong> to simplify the mathematical formulation of the Ridge and LASSO regression. In practice, we would not actually want to regularize the intercept term (and you should always assume that there should not be a regularization on the intercept term).</p>
<p>For example, if we choose <span class="math inline">\(g(\theta) = ||{\theta}||_2^2\)</span>, our goal is to find <span class="math inline">\(\hat{\theta}\)</span> that satisfies the equation below:</p>
<p><span class="math display">\[\begin{align*}
\hat\theta
= \underset{\theta}{\operatorname{argmin}} L_2(\theta)
&amp;= \underset{\theta}{\operatorname{argmin}} \left[ \dfrac{1}{n}||\mathbb{Y} - \Bbb{X}{\theta}||_2^2 + \lambda ||{\theta}||_2^2
\right] \\
&amp;= \underset{\theta}{\operatorname{argmin}} \left[ \dfrac{1}{n}\sum_{i=1}^n (y_i - \Bbb{X}_{i,\cdot}^T \theta) ^2 + \lambda \sum_{j=0}^d\theta_j^2 \right]
\end{align*}\]</span></p>
<p>Recall that <span class="math inline">\(\lambda\)</span> is a hyperparameter that determines the impact of the regularization term. Like ordinary least squares, we can also find a closed-form solution to Ridge regression: <span class="math inline">\(\hat{\theta}=(\Bbb{X}^T\Bbb{X} + n \lambda \mathbf{I})^{-1} \Bbb{X}^T \mathbb{Y}\)</span>. For LASSO regression, there is no such closed-form expression.</p>
<section id="a-1" class="level3">
<h3 class="anchored" data-anchor-id="a-1">(a)</h3>
<p>Suppose we are dealing with the OLS case (i.e., don’t worry about regularization yet). We increase the complexity of the model until test error stops decreasing. If we continue to increase model complexity, what do we expect to happen to the training error of the model trained using OLS? What about the test error?</p>
<p><span class="math inline">\(\Box\)</span> Training error decreases</p>
<p><span class="math inline">\(\Box\)</span> Training error increases</p>
<p><span class="math inline">\(\Box\)</span> Test error decreases</p>
<p><span class="math inline">\(\Box\)</span> Test error increases</p>
<details>
<summary>
<b>Answer</b>
</summary>
<p><strong>Training error decreases, Test error increases</strong></p>
<p>The training error decreases since the model fits/recognizes more relationships between features and responses found in the training dataset. However, these relationships increasingly become specific to the training set and will not necessarily generalize to the test set, so we expect the test error to increase.</p>
<p><em>Note:</em> The above is what we expect to happen, but there may be <em>rare cases</em> where this might not be true.</p>
</details>
</section>
<section id="b-1" class="level3">
<h3 class="anchored" data-anchor-id="b-1">(b)</h3>
<p>Now suppose we choose one of the above regularization methods, either <span class="math inline">\(L1\)</span> or <span class="math inline">\(L2\)</span>, for some regularization parameter <span class="math inline">\(\lambda &gt; 0\)</span> then we solve for our optimum. In terms of variance, how does a regularized model compare to ordinary least squares regression (assuming the same features between both models)?</p>
<details>
<summary>
<b>Answer</b>
</summary>
<p>Regularized regression has a <strong>lower</strong> variance relative to ordinary least squares regression. This is because regularization tends to make the model “simpler” (pushing the vector of regression coefficients to be in some ball around the origin). So, upon slight changes in input variables, our predictions will vary less under regularization than under no regularization.</p>
</details>
</section>
<section id="c" class="level3">
<h3 class="anchored" data-anchor-id="c">(c)</h3>
<p>Suppose we have a large number of features (10,000+), and we suspect that only a handful of features are useful. Would LASSO or Ridge regression be more helpful in interpreting useful features? Why?</p>
<details>
<summary>
<b>Answer</b>
</summary>
<p>LASSO would be better as it sets many values to 0, so it would be effectively selecting useful features and “ignoring” less useful ones.</p>
<p>You can see this behavior in the GIF above with two parameters!</p>
</details>
</section>
<section id="d" class="level3">
<h3 class="anchored" data-anchor-id="d">(d)</h3>
<p>What are the two benefits of using Ridge regression over OLS?</p>
<details>
<summary>
<b>Answer</b>
</summary>
<ol type="1">
<li><p>If <span class="math inline">\(\mathbb{X}^T\mathbb{X}\)</span> is not full rank (not invertible), then we end up with infinitely many solutions for least squares. On the other hand, using Ridge regression guarantees invertibility of <span class="math inline">\((\mathbb{X}^T\mathbb{X} + n \lambda \mathbb{I})\)</span> and ensures that <span class="math inline">\(\hat\theta = (\mathbb{X}^T\mathbb{X} + n \lambda \mathbb{I})^{-1}\mathbb{X}^T\mathbb{Y}\)</span> always has a unique solution when <span class="math inline">\(\lambda &gt; 0\)</span>; the proof for these facts is out of scope for Data 100.</p></li>
<li><p>Ridge regression also allows for feature selection/reducing overfitting because it down weights features that are less important in predicting the response. However, it still stands that LASSO is normally better for feature selection since LASSO will actually set these unimportant coefficients to <span class="math inline">\(0\)</span> as opposed to just down-weighting them.</p></li>
</ol>
</details>
</section>
<section id="e" class="level3">
<h3 class="anchored" data-anchor-id="e">(e)</h3>
<p>In Ridge regression, what happens to <span class="math inline">\(\hat{\theta}\)</span> if we set <span class="math inline">\(\lambda = 0\)</span>? What happens as <span class="math inline">\(\lambda\)</span> approaches <span class="math inline">\(\infty\)</span>?</p>
<details>
<summary>
<b>Answer</b>
</summary>
<ul>
<li><p><span class="math inline">\(\lambda = 0\)</span>: <span class="math display">\[\hat{\theta}=(\Bbb{X}^T\Bbb{X} + n \lambda \mathbf{I})^{-1} \Bbb{X}^T \mathbb{Y} =(\Bbb{X}^T\Bbb{X})^{-1} \Bbb{X}^T \mathbb{Y}\]</span> Which is the normal OLS solution.</p></li>
<li><p><span class="math inline">\(\lambda \rightarrow \infty\)</span>: <span class="math display">\[ (\Bbb{X}^T\Bbb{X} + n \lambda \mathbf{I})^{-1} \rightarrow \vec{0} \text{  as  } \lambda \rightarrow \infty \]</span> Therefore, <span class="math inline">\(\hat{\theta} \rightarrow \vec{0}\)</span> as well</p>
<ul>
<li>Intuitively: As <span class="math inline">\(\lambda \rightarrow \infty\)</span>, the penalty term will dominat ethe least-squares term. After a certain point, it will be more optimal to set <span class="math inline">\(\hat{\theta} = 0\)</span> and simply incur the loss of a constant model.</li>
</ul></li>
</ul>
</details>
</section>
</section>
<section id="guessing-at-random" class="level2">
<h2 class="anchored" data-anchor-id="guessing-at-random">Guessing at Random</h2>
<p>A multiple choice test has 100 questions, each with five answer choices. Assume for each question that there is only one correct choice. The grading scheme is as follows:</p>
<ul>
<li>4 points are awarded for each right answer.</li>
<li>For each other answer (wrong, missing, etc), one point is taken off; that is, -1 point is awarded.</li>
</ul>
<p>A student hasn’t studied at all and therefore selects each question’s answer uniformly at random, independently of all the other questions.</p>
<p>Define the following random variables:</p>
<ul>
<li><span class="math inline">\(R\)</span>: The number of answers the student gets right.</li>
<li><span class="math inline">\(W\)</span>: The number of answers the student does not get right.</li>
<li><span class="math inline">\(S\)</span>: The student’s score on the test.</li>
</ul>
<section id="a-2" class="level3">
<h3 class="anchored" data-anchor-id="a-2">(a)</h3>
<p>What is the distribution of <span class="math inline">\(R\)</span>? Provide the name and parameters of the appropriate distribution. Explain your answer.</p>
<details>
<summary>
<b>Answer</b>
</summary>
<p><span class="math inline">\(R\)</span> is counting the number of “successes” (or 1s) out of <span class="math inline">\(100\)</span> total independent Bernoulli trials, where a “success” is defined as answering the question correctly, and each question is a trial. The trials are independent because the student selects a random answer with the same probability distribution, no matter whether the other answers are chosen. The probability of “success” on any single trial is <span class="math inline">\(1/5 = 0.2\)</span>, so, <span class="math inline">\(R\)</span> must follow a binomial distribution with <span class="math inline">\(n = 100\)</span> and <span class="math inline">\(p = 0.2\)</span>.</p>
</details>
</section>
<section id="b-2" class="level3">
<h3 class="anchored" data-anchor-id="b-2">(b)</h3>
<p>Find <span class="math inline">\(\mathbb{E}[R]\)</span></p>
<details>
<summary>
<b>Answer</b>
</summary>
<p>From class, the expectation of a <span class="math inline">\(\text{Binomial}(n,p)\)</span> random variable is always <span class="math inline">\(np\)</span>. So, we obtain: <span class="math display">\[\mathbb{E}[R] = n \cdot p = 100 \cdot 0.2 = 20\]</span></p>
</details>
</section>
<section id="c-1" class="level3">
<h3 class="anchored" data-anchor-id="c-1">(c)</h3>
<p>True or False: <span class="math inline">\(\text{SD}(R) = \text{SD}(W)\)</span>? Remember that <span class="math inline">\(\text{Var}(X) = \text{SD}(X)^2\)</span>.</p>
<details>
<summary>
<b>Answer</b>
</summary>
<p>True. Note that <span class="math inline">\(R + W = 100\)</span>. Hence, <span class="math display">\[\begin{align*}
    \text{Var}(R) &amp;= \text{Var}(100 - W) \\
     &amp;= (-1)^2\text{Var}(W)\\
     &amp;= \text{Var}(W)
\end{align*}\]</span></p>
<p>We use the non-linearity of variance, <span class="math inline">\(\text{Var}(aX+b) = a^2\text{Var}(X)\)</span>, to simplify our expression.</p>
</details>
</section>
<section id="d-1" class="level3">
<h3 class="anchored" data-anchor-id="d-1">(d)</h3>
<p>Find <span class="math inline">\(\mathbb{E}[S]\)</span>, the student’s expected score on the test.</p>
<details>
<summary>
<b>Answer</b>
</summary>
<p>The student’s score on the test is a function of how many they get correct and how many they get incorrect. Using the point scheme given in the question, we can write this score as <span class="math inline">\(S = 4R - W\)</span> since each correct answer is awarded <span class="math inline">\(4\)</span> points, and each wrong answer is penalized by <span class="math inline">\(1\)</span> point. Note that <span class="math inline">\(S\)</span> is also a random variable since it is a function of random variables <span class="math inline">\(R\)</span> and <span class="math inline">\(W\)</span>. Note that <span class="math inline">\(R + W = 100\)</span>, since there are <span class="math inline">\(100\)</span> questions. Substituting <span class="math inline">\(W = 100 - R\)</span> and using linearity of expectations, we see:</p>
<p><span class="math display">\[\begin{align*}
    \mathbb{E}[S] &amp;= \mathbb{E}[4R - W] \\
    &amp;= \mathbb{E}[4R - 100 + R] \\
    &amp;= \mathbb{E}[5R - 100] \\
    &amp;= 5\mathbb{E}[R] - 100 \\
\end{align*}\]</span></p>
<p>Substituting <span class="math inline">\(\mathbb{E}[R] = 20\)</span> from part (b), we see the students expected score on the exam using this guessing strategy is <span class="math inline">\(0\)</span>.</p>
</details>
</section>
<section id="e-1" class="level3">
<h3 class="anchored" data-anchor-id="e-1">(e)</h3>
<p>Find <span class="math inline">\(\text{SD}(S)\)</span></p>
<details>
<summary>
<b>Answer</b>
</summary>
<p>We know from the question above that we can write <span class="math inline">\(4R - W\)</span> as <span class="math inline">\(5R - 100\)</span>. Since the variance of a random variable plus a constant is just the variance of the original random variable:</p>
<p><span class="math display">\[\begin{align*}
    \text{Var}(S) &amp;= \text{Var}(5R - 100) \\
    &amp;= 5^{2}\text{Var}(R) \\
    &amp;= 25\text{Var}(R)
\end{align*}\]</span></p>
<p>We know that the variance of a <span class="math inline">\(\text{Binomial}(n,p)\)</span> variable is <span class="math inline">\(np(1-p)\)</span>. Plugging in the values of <span class="math inline">\(n, p\)</span> from part (a), we see <span class="math inline">\(\text{Var}(R) = 16\)</span>, giving us <span class="math inline">\(\text{Var}(S) = 400\)</span>. Hence, <span class="math inline">\(SD(S) = \sqrt{400} = 20\)</span>.</p>
</details>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>